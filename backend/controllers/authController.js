  const User = require('../models/User');
  const bcrypt = require('bcryptjs');
  const jwt = require('jsonwebtoken'); // Pour gÃ©rer l'authentification
  const moment = require('moment');
  const {isMobilePhone} = require('validator');
  const normalizePhone = require('../utils/normalizePhone');


  // Authentification (login)
  exports.login = async (req, res) => {
    
    try {
      
      const { phone } = req.body;

      let phoneNumber = phone.toString().trim();

      console.log(phoneNumber);

      // Si le numÃ©ro commence par +225 ou 00225, on supprime lâ€™indicatif
      phoneNumber = normalizePhone(phone);

      console.log("after slice:",phoneNumber)

      const user = await User.findOne({ phone: phoneNumber });
      if (!user) {
        return res.status(404).json({ message: 'Utilisateur non trouvÃ©.' });
      }

      return res.status(200).json({ success: true, "user_info": user });

    } catch (error) {

      console.error("Erreur lors du login :", error);

    return res.status(500).json({ message: 'Erreur serveur.', error: error.message });
    }
  };

  // VÃ©rification de l'existence du numÃ©ro de tÃ©lÃ©phone
  exports.checkPhone = async (req, res) => {
    try {
      const { phone } = req.body;
      console.log(phone);

      const phoneNumber = normalizePhone(phone.trim())

      const existingUser = await User.findOne({ phoneNumber });

      if (existingUser) {
        return res.status(400).json({ message: 'NumÃ©ro dÃ©jÃ  utilisÃ©.', user: existingUser });
      }
      return res.status(200).json({ message: 'NumÃ©ro disponible.' });

      
    } catch (error) {
      return res.status(500).json({ message: 'Erreur serveur.', error });
    }
  };

  // Enregistrement du code PIN
  exports.setPin = async (req, res) => {
    try {

      console.log('REQUÃŠTE REÃ‡UE:', req.body);
      const { phone, code } = req.body;
      // affichage des infos
      console.log(
        {
        phone: phone,
        code: code
      });

      if (!/^\d{4}$/.test(code)) {
        return res.status(400).json({ message: 'Le code doit contenir exactement 4 chiffres.' });
      }

      // Normaliser le numÃ©ro de tÃ©lÃ©phone
      let phoneNumber = normalizePhone(phone.trim());

      // VÃ©rifier si le tÃ©lÃ©phone est bien fourni
      if (!phoneNumber) {
        return res.status(400).json({ message: 'Le numÃ©ro de tÃ©lÃ©phone est requis.' });
      }

      // Hachage du code PIN
      const hashedCode = await bcrypt.hash(code, 10);

      // Mettre Ã  jour l'utilisateur avec le code PIN hachÃ©
      const updatedUser = await User.findOneAndUpdate(
        { phone: phoneNumber },
        { code: hashedCode },
        { new: true }
      );

      if (!updatedUser) {
        return res.status(404).json({ message: 'Utilisateur non trouvÃ©.' });
      }
      return res.status(200).json({ message: 'Code PIN enregistrÃ©.', user: updatedUser });

    } catch (error) {
      console.error('Erreur dans setPin :', error);
      return res.status(500).json({
        message: 'Erreur serveur.',
        error: error?.message || error
      });
    }
  };

  // VÃ©rification du code PIN
  exports.verifyPin = async (req, res) => {
    try {
      const { phone, confirmCode } = req.body;

      // let phoneNumber = phone.toString().trim();
      // console.log(phoneNumber);
    
      const phoneNumber = normalizePhone(phone.trim());

      console.log(
        {
        'phone': phoneNumber,
        'confirmCode:': confirmCode
        });

      // Ã‰tape 1 : RÃ©cupÃ©rer l'utilisateur par son numÃ©ro de tÃ©lÃ©phone
      const user = await User.findOne({ phone: phoneNumber });

      if (!user) {
        return res.status(404).json({ message: 'Utilisateur introuvable.' });
      }

      const isMatch = await bcrypt.compare(confirmCode, user.code);
      if (!isMatch) {
        return res.status(400).json({ message: 'Code incorrect.' });
      }

      // GÃ©nÃ©rer un OTP et le stocker dans la base de donnÃ©es
      const otpGenerated = Math.floor(100000 + Math.random() * 900000).toString();
      console.log('code otp', otpGenerated);

      const otpExpires = moment().add(30, 'minutes').toDate(); // L'OTP expire dans 10 minutes

      // Mettre Ã  jour l'utilisateur avec l'OTP gÃ©nÃ©rÃ©
      await User.findOneAndUpdate(
        { phone: phoneNumber },
        { otp: otpGenerated, otpExpires },
        { new: true }
      );

      // Mise Ã  jour de l'Ã©tat de vÃ©rification du tÃ©lÃ©phone
      user.isPhoneVerified = true;
      await user.save(); 
      
      // GÃ©nÃ©ration du token JWT pour l'authentification
      const token = jwt.sign({ userId: user._id }, process.env.JWT_SECRET, { expiresIn: '1h' });

      return res.status(200).json(
        { success: true, 
          message: 'Authentification rÃ©ussie. OTP gÃ©nÃ©rÃ© avec succÃ¨s.', 
          otp: otpGenerated,
          token,
          user: {
            id: user._id,
            firstName: user.firstName,
            lastName: user.lastName,
            email: user.email,
            phone: user.phone,
            status: user.status, 
            solde: user.solde,  
            email: user.email,
            gender: user.gender,
            birthday: user.birthday,
            address: user.address,
          }
        });

    } catch (error) {
      
      return res.status(500).json({
        message: 'Erreur serveur.',
        error: error.message || error, });
    }
  };

  // Enregistrer numÃ©ro de tÃ©lÃ©phone
  exports.savedPhone = async (req, res) => {
    try {

      console.log("ðŸ“ž RequÃªte reÃ§ue :", req.body);

      let { phone } = req.body;
      if (!phone) return res.status(400).json({ message: 'NumÃ©ro requis.' });

      const phoneNumber = normalizePhone(phone);
      console.log("NumÃ©ro normalisÃ©:", phoneNumber);

      const isPhoneValid = isMobilePhone(phoneNumber, 'any', { strictMode: false });
      if (!isPhoneValid) {
        return res.status(400).json({ message: "NumÃ©ro de tÃ©lÃ©phone invalide." });
      }

      const existingUser = await User.findOne({ phone: phoneNumber });
      if (existingUser) {
        return res.status(400).json({ message: 'NumÃ©ro dÃ©jÃ  utilisÃ©.', user: existingUser });
      }

      const newUser = new User({ phone: phoneNumber });
      await newUser.save();

      console.log("âœ… Utilisateur crÃ©Ã© :", newUser);
      return res.status(200).json({ message: 'Utilisateur crÃ©Ã© avec succÃ¨s.', user: newUser });

      

    } catch (error) {
      return res.status(500).json({ message: 'Erreur serveur.', error });
    }
  };

  // VÃ©rification de l'OTP
  exports.verifyOtp = async (req, res) => {
    try {
      console.log('VÃ©rification OTP - RequÃªte reÃ§ue:', req.body);
      let { phone, otp } = req.body;

      let phoneNumber = normalizePhone(phone.trim());

      if (!phone || !otp) {
        return res.status(400).json({ message: 'NumÃ©ro de tÃ©lÃ©phone et OTP requis.' });
      }

      const user = await User.findOne({ phone: phoneNumber });
      if (!user) {
        return res.status(404).json({ message: 'Utilisateur non trouvÃ©.' });
      }

      if (user.otp !== otp) {
        return res.status(400).json({ message: 'Code OTP incorrect.' });
      }

      if (moment().isAfter(user.otpExpires)) {
        return res.status(400).json({ message: 'Code OTP expirÃ©.' });
      }

      user.otp = null;
      user.otpExpires = null;
      user.isPhoneVerified = true;
      await user.save();

      // GÃ©nÃ©ration du token (si tu veux sÃ©curiser les routes ensuite)
      const token = jwt.sign({ userId: user._id }, process.env.JWT_SECRET, {
        expiresIn: '1h',
      });

      // On renvoie les infos minimales Ã  stocker cÃ´tÃ© front
      return res.status(200).json({
        message: 'OTP vÃ©rifiÃ© avec succÃ¨s.',
        user: {
          _id: user._id,
          phone: user.phone,
          firstName: user.firstName || '',
          lastName: user.lastName || '',
          isPhoneVerified: user.isPhoneVerified,
          isIdentityVerified: user.isIdentityVerified,
        },
        token,
      });

    } catch (error) {
      console.error('Erreur serveur lors de la vÃ©rification OTP:', error);
      return res.status(500).json({
        message: 'Erreur serveur.',
        error: error.message,
      });
    }
  };

  // Mise Ã  jour de l'identitÃ© de l'utilisateur
  exports.updateIdendity = async (req, res) => {
    try {
      const { phone } = req.body;
      console.log("TÃ©lÃ©phone reÃ§u :", phone);

      // VÃ©rifier que le tÃ©lÃ©phone est bien fourni
      if (!phone || typeof phone !== "string" || phone.trim() === "") {
        return res.status(400).json({ message: "Le numÃ©ro de tÃ©lÃ©phone est requis." });
      }

      // Nettoyer le numÃ©ro (par exemple enlever les espaces)
      const cleanPhone = phone.trim();

      // Rechercher l'utilisateur par numÃ©ro de tÃ©lÃ©phone
      const user = await User.findOne({ phone: cleanPhone });

      if (!user) {
        console.log("Utilisateur introuvable avec le numÃ©ro :", cleanPhone);
        return res.status(404).json({ message: "Utilisateur non trouvÃ©." });
      }

      // VÃ©rifier si l'identitÃ© est dÃ©jÃ  validÃ©e
      if (user.isIdentityVerified) {
        return res.status(400).json({ message: "IdentitÃ© dÃ©jÃ  passÃ©e." });
      }

      // Marquer l'identitÃ© comme validÃ©e
      user.isIdentityVerified = true;
      await user.save();

      console.log("IdentitÃ© passÃ©e pour :", cleanPhone);
      return res.status(200).json({ message: "IdentitÃ© passÃ©e avec succÃ¨s." });

    } catch (error) {
      console.error("ðŸ”¥ Erreur serveur:", error);
      return res.status(500).json({ message: "Erreur serveur.", error: error.message });
    }
  };

  // VÃ©rification de l'identitÃ© (nom, prÃ©noms, etc.) 
  exports.verifyIdentity = async (req, res) => {
    try {

      const { phone, gender, firstName, lastName, address, email, birthday } = req.body;
      console.log('DonnÃ©es reÃ§ues :', req.body);

      let phoneNumber = normalizePhone(phone.trim());

      // VÃ©rification des champs requis
      if (!phone || !firstName || !lastName || !gender || !address || !email || !birthday) {
        return res.status(400).json({ message: 'Tous les champs sont requis.' });
      }

      // Rechercher et mettre Ã  jour l'utilisateur
      const updatedUser = await User.findOneAndUpdate(
        { phone },
        {
          firstName,
          lastName,
          gender,
          address,
          email,
          birthday,
        },
        { new: true }
      );

      if (!updatedUser) {
        return res.status(404).json({ message: "Utilisateur introuvable avec ce numÃ©ro." });
      }

      return res.status(200).json({
        success: true,
        message: 'IdentitÃ© vÃ©rifiÃ©e et mise Ã  jour.',
        user: updatedUser,
      });

    } catch (error) {
      console.error("Erreur verifyIdentity :", error);
      return res.status(500).json({ message: 'Erreur serveur.', error: error.message });
    }
  };







